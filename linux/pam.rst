PAM - 可插拔认证模块
=====================

`Pluggable Authentication Modules <http://www.linux-pam.org/>`_
可插拔认证模块，为了实现其插件功能和模块化设计，采取了分层设计思想，就是让各模块从应用程序中独立出来，然后通过PAM
API作为两者联系的纽带，使用户可以轻易地在应用程序中插入新的认证模块或替换原先的组件，同时不必对应用程序做任何修改，
这样应用程序就可以根据需要灵活地在其中插入所需要的功能模块。 [#]_

配置
----
::

 /etc/pam.conf/*

配置文件也放在了在应用接口层中，他与PAM
API配合使用，从而达到了在应用中灵活插入所需鉴别模块的目的。他的作用主要是为应用选定具体的鉴别模块，模块间的组合以及规定模块的行为。
配置文件由配置项(每行对应一个配置项)组成，每一行又分为四列，第一列为PAM接口类型，
第二列为PAM控制类型，第三列为PAM模块，第四列为PAM传递参数 [#]_

接口类型
~~~~~~~~

指明程序所使用的PAM的认证接口类型，这四种接口并不是所有应用程序都必需的，而是根据需要选取。

-  **auth**
   验证类接口，用于检查用户和密码，并分配权限；这种类型的模块为用户验证提供两方面服务。让应用程序提示用户输入密码或者其他标记，确认用户合法性；通过他的凭证许可权限，设定组成员关系或者其他优先权。

-  **account**
   帐户类接口，主要负责账户合法性检查，确认帐号是否过期，是否有权限登录系统等；这种模块执行的是基于非验证的帐号管理。他主要用于限制/允许用户对某个服务的访问时间，当前有效的系统资源（最多可以多少用户），限制用户位置（例如：root只能通过控制台登录）。多数情况下auth和account会一起用来对用户登录和使用服务的情况进行限制。这样的限制会更加完整。

-  **password**
   口令类接口。控制用户更改密码的全过程，也就是有些资料所说的升级用户验证标记。

-  **session**
   会话类接口，实现从用户登录成功到退出的会话控制；处理为用户提供服务之前/后需要做的些事情。包括：开启/关闭交换数据的信息，监视目录等，设置用户会话环境等。也就是说这是在系统正式进行服务提供之前的最后一道关口。

控制类型
~~~~~~~~

规定如何处理PAM模块鉴别认证的结果，简而言之就是鉴别认证成功或者失败之后会发生什么事，如何进行控制。

-  **required**
   表示该行以及所涉及模块的成功是用户通过鉴别的必要条件。只有当所有带
   required标记的模块全部认证成功后，该程序才能通过鉴别。同时，如果任何带required标记的模块出现了错误，PAM并不立刻将错误消息返回给应用程序，而是在所有模块都调用完毕后才将错误消息返回调用他的程序。这样做的目的就是不让用户知道自己被哪个模块拒绝，通过一种隐蔽的方式来保护系统服务。

-  **requisite**
   与required相仿，只有带此标记的模块返回成功后，用户才能通过鉴别。不同之处在于其一旦失败就不再执行堆中后面的其他模块，并且鉴别过程到此结束，同时也会立即返回错误信息。

-  **optional**
   表示即便该行所涉及的模块验证失败用户仍能通过认证。在PAM体系中，带有该标记的模块失败后将继续处理下一模块。也就是说即使本行指定的模块验证失败，也允许用户享受应用程序提供的服务。使用该标志，PAM框架会忽略这个模块产生的验证错误，继续顺序执行下一个层叠模块。

-  **sufficient**
   表示该行以及所涉及模块验证成功是用户通过鉴别的充分条件。也就是说只要标记为sufficient的模块一旦验证成功，那么PAM便立即向应用程序返回成功结果而不必尝试任何其他模块。即便后面的层叠模块使用了requisite或者required控制标志也是一样。当标记为sufficient的模块失败时，sufficient模块会当做
   optional对待。因此拥有sufficient
   标志位的配置项在执行验证出错的时候并不会导致整个验证失败，但执行验证成功之时则大门敞开。所以该控制位的使用务必慎重。

-  **include**
   表示在验证过程中调用其他的PAM配置文件。在RHEL系统中有相当多的应用通过完整调用/etc/pam.d/system-auth来实现认证而不需要重新逐一去写配置项。这也就意味着在很多时候只要用户能够登录系统，针对绝大多数的应用程序也能同时通过认证。

模块路径
~~~~~~~~

::

 i368/i686：/lib/security/
 x86_64：/lib64/security

**pam_access.so**
根据主机名（包括普通主机名或者FQDN）、IP地址和用户实现全面的访问控制。 [#]_

**pam_tally.so**
监控用户的不成功登录尝试的次数，在达到模块限制的次数时会锁定用户一段时间以防止一些黑客软件的暴力破解。 [#]_

**pam_env.so** 设置和更改用户登录后的环境变量

**pam_unix.so**
提示用户输入密码，并将用户密码与/etc/shadow中记录的密码信息进行对比

**pam_succeed_if.so** 对用户的登录条件做一些限制

**pam_deny.so**
该模块是一个特殊的模块，返回值永远为否，类似于大多数安全机制的配置准则，在所有认证规则走完之后，对不匹配任何规则的请求直接拒绝。

**pam_keyinit.so**
当用户登录的时候为其建立相应的密钥环，并在用户登出的时候予以撤销

**pam_limits.so** 限制用户会话过程中对各种系统资源的使用情况

**pam_rootok.so**
使uid为0的用户，即root用户能够直接通过认证而不用输入密码。

传递参数
~~~~~~~~

向模块传递诸如URL或超时值之类的参数等

.. rubric:: 参考文献

.. [#] `Linux可插拔认证模块的基本概念与架构 <http://www.infoq.com/cn/articles/wjl-linux-pluggable-authentication-module>`_
.. [#] `Linux可插拔认证模块（PAM）的配置文件、工作原理与流程 <http://www.infoq.com/cn/articles/linux-pam-one>`_
.. [#] `常用的Linux可插拔认证模块（PAM）应用举例（一） <http://www.infoq.com/cn/articles/linux-pam-two>`_
.. [#] `常用的Linux可插拔认证模块（PAM）应用举例（二） <http://www.infoq.com/cn/articles/linux-pam-three>`_
